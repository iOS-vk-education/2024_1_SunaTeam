//
//  arr_notes.swift
//  SunaTravel
//
//  Created by Lilia Chechina on 15.03.2025.
//
import Foundation
import SwiftUI
import FirebaseFirestore
import FirebaseFirestoreSwift

class NoteViewModel: ObservableObject {
    @Published var notes: [Note] = []
    @Published var selectedNote: Note?  // to prevent crash
    
    private let db = Firestore.firestore()             // create an instance of Firestore
    private var userId: String
    private var tripId: String
    
    private let notesCollection = "notes"
    
    // initialize data when creating ViewModel
    init(userId: String, tripId: String) {
            self.userId = userId
            self.tripId = tripId
            loadNotes()
        }
    
    private var notesCollectionRef: CollectionReference {
           db.collection("userData").document(userId)
               .collection("trips").document(tripId)
               .collection("notes")
       }

    func addNote(title: String, text: String, completion: @escaping (Note) -> Void) {
        let docRef = notesCollectionRef.document()
        var newNote = Note(id: docRef.documentID, title: title, text: text)  // Create a note instance with the same ID generated by Firestore

        // serialization
        do {
            try docRef.setData(from: newNote) { error in
                if let error = error {
                    print("Error adding note: \(error.localizedDescription)")
                } else {
                    print("Note successfully added!")
                    completion(newNote)
                }
            }
        } catch {
            print("Error encoding note: \(error)")
        }
    }


    func deleteNote(note: Note) {
        guard let id = note.id else { return }

        notesCollectionRef.document(id).delete { [weak self] error in
            if let error = error {
                print("Error deleting note: \(error)")
            } else {
                print("Note deleted from Firestore.")
                if let index = self?.notes.firstIndex(where: { $0.id == note.id }) {
                    self?.notes.remove(at: index)
                }
            }
        }
    }




    func updateNote(_ note: Note) {
        guard let id = note.id else { return }

        do {
                    try notesCollectionRef.document(id).setData(from: note)
                } catch {
                    print("Error updating note: \(error)")
                }
    }

    func loadNotes() {
        notesCollectionRef.addSnapshotListener { [weak self] snapshot, error in
            guard let documents = snapshot?.documents else {
                print("Error loading notes: \(error?.localizedDescription ?? "No data")")
                return
            }

            let updatedNotes = documents.compactMap { try? $0.data(as: Note.self) }
            self?.notes = updatedNotes.filter { $0.id != nil }
        }
    }

}

