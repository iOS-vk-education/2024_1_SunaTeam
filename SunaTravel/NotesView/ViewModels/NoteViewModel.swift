//
//  arr_notes.swift
//  SunaTravel
//
//  Created by Lilia Chechina on 15.03.2025.
//
import Foundation
import SwiftUI
import FirebaseFirestore
import FirebaseFirestoreSwift

class NoteViewModel: ObservableObject {
    @Published var notes: [Note] = []
    @Published var selectedNote: Note?  // to prevent crash
    
    private let db = Firestore.firestore()             // create an instance of Firestore
    private let notesCollection = "notes"
    
    // initialize data when creating ViewModel
    init() {
        loadNotes()
    }
    

    func addNote(title: String, text: String, completion: @escaping (Note) -> Void) {
        let docRef = db.collection("notes").document()  // сreate a link to a new document in the notes collection
        var newNote = Note(id: docRef.documentID, title: title, text: text)  // Create a note instance with the same ID generated by Firestore

        // serialization
        do {
            try docRef.setData(from: newNote) { error in
                if let error = error {
                    print("Error adding note: \(error.localizedDescription)")
                } else {
                    print("Note successfully added!")
                    self.notes.append(newNote)
                    completion(newNote)
                }
            }
        } catch {
            print("Error encoding note: \(error)")
        }
    }

    func deleteNote(note: Note) {
        if let index = notes.firstIndex(where: { $0.id == note.id }) {  // If there is a note in the notes array with the same id as the note that needs to be deleted, we delete it from the array.
            // $0 — this is each note from the notes array
            notes.remove(at: index)
            if let id = note.id {
                let db = Firestore.firestore()  // Firestore database link
                db.collection("notes").document(id).delete { error in
                    if let error = error {
                        print("Error deleting note from Firestore: \(error.localizedDescription)")
                    } else {
                        print("The note has been successfully deleted from Firestore.")
                    }
                }
            }
        }
    }

    func updateNote(_ note: Note) {
        guard let noteId = note.id else {
            print("Error: note has no id")
            return
        }

        do {
            try db.collection(notesCollection)
                .document(noteId)
                .setData(from: note)
        } catch {
            print("Error updating note: \(error)")
        }
    }

    func loadNotes() {
        db.collection(notesCollection)
        // addSnapshotListener – real listening to the collection in Firestore.
        // When at least one note changes (added, deleted, changed) - this block is automatically called again
            .addSnapshotListener { [weak self] snapshot, error in
                guard let documents = snapshot?.documents else {  // Checking if documents arrived from Firestore
                    print("Error loading notes: \(error?.localizedDescription ?? "No data")")
                    return
                }
                
                self?.notes = documents.compactMap { document in
                    try? document.data(as: Note.self)
                }
                //  self?.notes = ... — we save the received notes in the @Published var notes so that SwiftUI can update the interface.
                // compactMap - creates an array of [Note], discarding those that could not be decoded (try? returned nil)
            }
    }
}
